# DS_hw2

## Q1 

1.6 2 产生测试数据

想要得到能够使程序表现得最差的数据集合也不总是那么简单。在一些情况下，我们需要通过电脑程序生成这种最差情况的数据集合。而在另外一些情况中，这样的行为都会变得十分困难。这样的时候，我们就需要使用另外一种评估最差情况的性能的方法了。针对每一个实例特征的值的集合，我们都可以生成一些适当大的随机测试数据。于是我们可以得到每一个测试数据的运行时间。而最长的运行时间就可以用作估计这些实例特征的值集合的最差情况的时间开销。

如果要测量平均情况的耗时，对所有可能的实例特征的时间做一个平均值计算是不太可能的。尽管这样的做法在对连续寻找算法和二分查找算法取平均情况时是可行的，但却不适用于排序程序。如果我们假定所有的关键字都是不同的，那么无论n是多少，每次想要得到平均时间都需要做n！的排列组合次运算。

想得到平均情况耗时通常会比得到最差情况耗时要难得多。所以，我们通常会通过使用上面提到的随机数方法得到的平均耗时来评估这个程序的平均耗时。

无论是使用随机数据评估最差情况或者是平均情况的时间，我们能够使用的例子的数目总体来说是比所有的可能性要小得多的。因此，分析这些决定在实验中生成的数据的种类的算法肯定会变成一件抢手的任务。这很明显是个我们现在不应该涉及的算法方面的问题。


## Q2

课后习题7

非迭代算法:
```
int iterativeFactorialCal(int n){
	int result = 1;
	for(int i = 1; i <= n; i++){
		result *= i;
	}
	return result;
}

```

其空间复杂度为：S(P) = c + Sp(I)，只有定长空间需求：参数n和局部变量result，2 * 4个字节。

迭代算法：
```
int recursiveFactorialCal(int n){
	if(n <= 1){
		return 1;
	}else return n * recursiveFactorialCal(n - 1);
}
```

其空间复杂度为：S(P) = c + Sp(I) = n + S(n)
每次需要保留参数和返回地址 就是2 * 4 * n的字节数。

## Q3

课后习题8

非递归：
```
int iterativeFibonacciCal(int n){
    int result_m = 0, result = 1;
    for(int i = 1; i < n; i++){
        int temp = result_m;
        result_m = result;
        result += temp;
    }
    if(n == 0)
        return 0;
    return result;
}
```
空间复杂度都来自于定长空间需求，需要参数，result_m，result，temp，返回地址这五个定长的空间需求：5 * 4字节。


递归：
```
int recursiveFibonacciCal(int n){
    if(n == 0)
        return 0;
    else if(n == 1)
        return 1;
    else return recursiveFibonacciCal(n - 1) + recursiveFibonacciCal(n - 2);
}
```

每次递归需要参数，返回地址 ，2 * 4 * n的字节数的空间需求。

## Q4

(a) 5n^2 + 6n = ø(n^2)
由定理1.4可知，一个任意参数的m次多项式的时间复杂度等于ø(n^m)，故表达式(a)正确。

(b) n! = O(n^n)
展开n!可得n的n次多项式：n*(n-1)*(n-2)*...*2*1。由定理1.2可知，一个任意参数的m次多项式的时间复杂度的上界为n^m，所以(b)式成立。

(c) 2n^2 + nlog(n) = ø(n^2)
由(c)式前后两部分函数曲线可知，当n>0时，2n^2部分决定整个函数的大致走向，n^2是左式的上界与下界，由定理1.4可知，表达式(c)成立

(d) ∑i^2 = ø(n^3)
可将左式∑i^2分解为:0^2 + 1^2 + ... + n^2  (1)
易知分解式(1) <= n^2 + n^2 + ... n^2 = n * n^2 = n^3  (2)
由(1)与(2)可知n^3为左式上界
又可得：(1) = (0^2 + n^2) + (1^2 + (n-1)^2) + ... + (n/2)^2
= n^2 + n^2 - 2n + n^2 - 4n + ... + (n/2)^2 ≥ (n/2)^2 * n
= 1/4 * n^3  (3)
由(1)与(3)可知n^3为左式下界
由ø(theta)符号定义可知，c1g(n) ≤ ƒ(n) ≤ c2g(n)，式(2)(3)可得c1=1/4，c2=1，故n^3同时为∑i^2的上下界，式子(d)成立。

(e) ∑i^3 = ø(n^4)
同理于(d)。
可用同样的变形得到c1g(n) ≤ ƒ(n) ≤ c2g(n)中的c1=1/8，c2=1，故n^4同时为左式的上下界，(e)成立。

(f) n^(2^n) + 6*2^n = ø(n^(2^n))
同理(c)，当n>0时，n^(2^n)部分决定整个函数的大致走向，n^(2^n)是左式的上界与下界，由定理1.4可知，表达式(f)成立

(g) n^3 + 10^6*n^2 = ø(n^3)
同理于(a)，由定理1.4可知，一个任意参数的m次多项式的时间复杂度等于ø(n^m)，故表达式(g)正确。

(h) 6n^3 / (log(n) + 1) = O(n^3)
由于上式除以log(n)，n^3为左式上界，式子(h)成立。

(i) n^1.001 + n*log(n) = ø(n^1.001)
同理于(b)，n^1.001同时为左式上下界，式子(i)成立。

(j) n^k + n + n^k*log(n) = ø(n^k*log(n)) for all k≥1
同理于(c)，乘以log(n)后n^k*log(n)次数最高，由定理1.4可知(j)成立

(k) 10*n^3 + 15*n^4 + 100*n^2*2^n = O(n^2*2^n)
同理于(b)，c在此时等于100， 在c取值为比100大的任意一个数时，n^2*2^n是左式的上界，故(k)成立。

## Q5

```
void printMatrix(int matrix[][MAX_SIZE], int rows, int cols){
    int i, j;
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++){
            printf("%d", matrix[i][j]);
        }
        printf("\n");
    }
}
```

程序1.19中，使用了嵌套的for循环语句来完成对矩阵的打印，其中的最差情形的复杂程度主要来自于处于嵌套循环中的第四行，所以最差复杂度为O(rows*cols)

## Q6

```
void transpose(int a[][MAX_SIZE]){
    int i, j, temp;
    for (i = 0; i < MAX_SIZE-1; i++)
        for (j = i+1; j < MAX_SIZE; j++)
        SWAP(a[i][j], a[j][i], temp);
}
```

程序1.22中，同样适用了嵌套得for循环语句完成对矩阵的转置，不同的是第二层循环只对对角线以上的元素进行操作，所以最差时间复杂度是O((MAX_SIZE-1)^2)